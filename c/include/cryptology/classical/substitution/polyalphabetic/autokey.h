/**
 * @file autokey.h
 * @brief Auto-key cipher implementation
 * 
 * The Auto-key cipher is a polyalphabetic substitution cipher that automatically
 * extends the key using the plaintext itself. This makes it more secure than
 * Vigenère but also more complex.
 * 
 * Key features:
 * - Self-extending key: Key grows with plaintext length
 * - More secure: Harder to break than Vigenère
 * - Same table: Uses Vigenère's tabula recta
 * - Composable: Can use custom tables generated by monoalphabetic ciphers
 * - English (26x26) and Turkish (29x29) table sizes
 * - Random key generation for enhanced security
 */

#ifndef AUTOKEY_H
#define AUTOKEY_H

#include <stddef.h>
#include <stdarg.h>

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @brief Generate a cryptographically secure random key
 * 
 * @param length Length of the key to generate
 * @param alphabet The alphabet to use for key generation
 * @param result Buffer to store the generated key
 * @param result_size Size of the result buffer
 * @return 0 on success, -1 on error
 */
int autokey_generate_random_key(int length, const char *alphabet, 
                                char *result, size_t result_size);

/**
 * @brief Generate a random key matching the plaintext length
 * 
 * @param plaintext The text to encrypt (determines key length)
 * @param alphabet The alphabet to use for key generation
 * @param result Buffer to store the generated key
 * @param result_size Size of the result buffer
 * @return 0 on success, -1 on error
 */
int autokey_generate_key_for_text(const char *plaintext, const char *alphabet,
                                  char *result, size_t result_size);

/**
 * @brief Encrypt plaintext using a randomly generated key
 * 
 * @param plaintext Text to encrypt
 * @param table Custom Auto-key table (uses classical if NULL)
 * @param alphabet The alphabet to use
 * @param key_length Length of random key (uses text length if 0)
 * @param encrypted Buffer to store encrypted text
 * @param encrypted_size Size of the encrypted buffer
 * @param generated_key Buffer to store the generated key
 * @param key_size Size of the key buffer
 * @return 0 on success, -1 on error
 */
int autokey_encrypt_with_random_key(const char *plaintext, char ***table, 
                                   const char *alphabet, int key_length,
                                   char *encrypted, size_t encrypted_size,
                                   char *generated_key, size_t key_size);

/**
 * @brief Create classical Auto-key table (same as Vigenère tabula recta)
 * 
 * @param alphabet The alphabet to use for the table
 * @param table Pointer to store the generated table
 * @return 0 on success, -1 on error
 */
int autokey_create_classical_table(const char *alphabet, char ***table);

/**
 * @brief Create Auto-key table where each row uses Caesar cipher with different offsets
 * 
 * @param alphabet The alphabet to use for the table
 * @param shift Base shift for Caesar cipher
 * @param table Pointer to store the generated table
 * @return 0 on success, -1 on error
 */
int autokey_create_caesar_table(const char *alphabet, int shift, char ***table);

/**
 * @brief Create Auto-key table where each row uses Affine cipher with different offsets
 * 
 * @param alphabet The alphabet to use for the table
 * @param a Affine cipher parameter a
 * @param b Affine cipher parameter b
 * @param table Pointer to store the generated table
 * @return 0 on success, -1 on error
 */
int autokey_create_affine_table(const char *alphabet, int a, int b, char ***table);

/**
 * @brief Create Auto-key table where each row uses Keyword cipher with different keywords
 * 
 * @param alphabet The alphabet to use for the table
 * @param keyword Base keyword for the cipher
 * @param table Pointer to store the generated table
 * @return 0 on success, -1 on error
 */
int autokey_create_keyword_table(const char *alphabet, const char *keyword, char ***table);

/**
 * @brief Create Auto-key table where each row uses Atbash cipher with different offsets
 * 
 * @param alphabet The alphabet to use for the table
 * @param table Pointer to store the generated table
 * @return 0 on success, -1 on error
 */
int autokey_create_atbash_table(const char *alphabet, char ***table);

/**
 * @brief Produce an Auto-key table using different strategies
 * 
 * @param table_type Type of table ("classical", "caesar", "affine", "keyword", "atbash")
 * @param alphabet The alphabet to use for the table
 * @param table Pointer to store the generated table
 * @param ... Additional parameters for specific table types
 * @return 0 on success, -1 on error
 */
int autokey_produce_table(const char *table_type, const char *alphabet, 
                         char ***table, ...);

/**
 * @brief Prepare text for encryption by cleaning and handling special cases
 * 
 * @param text The input text
 * @param alphabet The alphabet being used
 * @param result Buffer to store the prepared text
 * @param result_size Size of the result buffer
 * @return 0 on success, -1 on error
 */
int autokey_prepare_text(const char *text, const char *alphabet,
                        char *result, size_t result_size);

/**
 * @brief Prepare ciphertext for decryption by cleaning
 * 
 * @param ciphertext The input ciphertext
 * @param result Buffer to store the prepared ciphertext
 * @param result_size Size of the result buffer
 * @return 0 on success, -1 on error
 */
int autokey_prepare_ciphertext(const char *ciphertext,
                              char *result, size_t result_size);

/**
 * @brief Extend the key using the plaintext (Auto-key mechanism)
 * 
 * @param key The initial key
 * @param plaintext The plaintext to extend the key with
 * @param alphabet The alphabet being used
 * @param result Buffer to store the extended key
 * @param result_size Size of the result buffer
 * @return 0 on success, -1 on error
 */
int autokey_extend_key(const char *key, const char *plaintext, const char *alphabet,
                      char *result, size_t result_size);

/**
 * @brief Extend the key for decryption using already decrypted text
 * 
 * @param key The initial key
 * @param decrypted_so_far The text decrypted so far
 * @param alphabet The alphabet being used
 * @param result Buffer to store the extended key
 * @param result_size Size of the result buffer
 * @return 0 on success, -1 on error
 */
int autokey_extend_key_for_decryption(const char *key, const char *decrypted_so_far, 
                                     const char *alphabet, char *result, size_t result_size);

/**
 * @brief Encrypt plaintext using Auto-key cipher
 * 
 * @param plaintext The text to encrypt
 * @param key The Auto-key initial key
 * @param table Custom Auto-key table (uses classical if NULL)
 * @param alphabet The alphabet to use (defaults to English)
 * @param encrypted Buffer to store encrypted text
 * @param encrypted_size Size of the encrypted buffer
 * @return 0 on success, -1 on error
 */
int autokey_encrypt(const char *plaintext, const char *key, char ***table,
                   const char *alphabet, char *encrypted, size_t encrypted_size);

/**
 * @brief Decrypt ciphertext using Auto-key cipher
 * 
 * @param ciphertext The text to decrypt
 * @param key The Auto-key initial key
 * @param table Custom Auto-key table (uses classical if NULL)
 * @param alphabet The alphabet to use (defaults to English)
 * @param decrypted Buffer to store decrypted text
 * @param decrypted_size Size of the decrypted buffer
 * @return 0 on success, -1 on error
 */
int autokey_decrypt(const char *ciphertext, const char *key, char ***table,
                   const char *alphabet, char *decrypted, size_t decrypted_size);

#ifdef __cplusplus
}
#endif

#endif /* AUTOKEY_H */
