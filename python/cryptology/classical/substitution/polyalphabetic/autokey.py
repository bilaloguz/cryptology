"""
Auto-key Cipher implementation.

The Auto-key cipher is a polyalphabetic substitution cipher that automatically
extends the key using the plaintext itself. This makes it more secure than
Vigenère but also more complex.

Key features:
- Self-extending key: Key grows with plaintext length
- More secure: Harder to break than Vigenère
- Same table: Uses Vigenère's tabula recta
- Composable: Can use custom tables generated by monoalphabetic ciphers
- English (26x26) and Turkish (29x29) table sizes
- Random key generation for enhanced security
"""

import secrets
from typing import List, Optional, Tuple
from ..monoalphabetic.caesar import produce_alphabet as caesar_produce
from ..monoalphabetic.keyword import produce_alphabet as keyword_produce
from ..monoalphabetic.affine import produce_alphabet as affine_produce
from ..monoalphabetic.atbash import produce_alphabet as atbash_produce

import cryptology.alphabets as ALPHABETS

DEFAULT_ALPHABET = ALPHABETS.ENGLISH_ALPHABET
TURKISH_ALPHABET = ALPHABETS.TURKISH_STANDARD


def generate_random_key(length: int, alphabet: str = DEFAULT_ALPHABET) -> str:
    """
    Generate a cryptographically secure random key.
    
    Args:
        length: Length of the key to generate
        alphabet: The alphabet to use for key generation
        
    Returns:
        A random key of the specified length
        
    Raises:
        ValueError: If length is not positive or alphabet is empty
    """
    if length <= 0:
        raise ValueError("Key length must be positive")
    
    if not alphabet:
        raise ValueError("Alphabet cannot be empty")
    
    # Generate random key using cryptographically secure random
    key = ''.join(secrets.choice(alphabet) for _ in range(length))
    return key


def generate_key_for_text(plaintext: str, alphabet: str = DEFAULT_ALPHABET) -> str:
    """
    Generate a random key matching the plaintext length.
    
    Args:
        plaintext: The text to encrypt (determines key length)
        alphabet: The alphabet to use for key generation
        
    Returns:
        A random key matching the plaintext length
    """
    if not plaintext:
        return ""
    
    # Count only alphabetic characters (spaces are preserved in encryption)
    alphabetic_chars = sum(1 for c in plaintext.lower() if c.isalpha())
    return generate_random_key(alphabetic_chars, alphabet)


def encrypt_with_random_key(plaintext: str,
                          table: Optional[List[List[str]]] = None,
                          alphabet: str = DEFAULT_ALPHABET,
                          key_length: Optional[int] = None) -> Tuple[str, str]:
    """
    Encrypt plaintext using a randomly generated key.
    
    Args:
        plaintext: Text to encrypt
        table: Custom Auto-key table (uses classical if None)
        alphabet: The alphabet to use
        key_length: Length of random key (uses text length if None)
        
    Returns:
        Tuple of (encrypted_text, generated_key)
        
    Raises:
        ValueError: If plaintext is empty or key_length is invalid
    """
    if not plaintext:
        raise ValueError("Plaintext cannot be empty")
    
    # Generate random key
    if key_length is None:
        key = generate_key_for_text(plaintext, alphabet)
    else:
        key = generate_random_key(key_length, alphabet)
    
    # Encrypt using the generated key
    encrypted = encrypt(plaintext, key, table, alphabet)
    
    return encrypted, key


def _create_classical_table(alphabet: str) -> List[List[str]]:
    """
    Create classical Auto-key table (same as Vigenère tabula recta).
    
    Args:
        alphabet: The alphabet to use for the table
        
    Returns:
        A 2D list representing the classical Auto-key table
    """
    alphabet_len = len(alphabet)
    table = []
    
    for i in range(alphabet_len):
        row = []
        for j in range(alphabet_len):
            # Each row is a Caesar cipher shifted by row index
            row.append(alphabet[(j + i) % alphabet_len])
        table.append(row)
    
    return table


def _create_caesar_table(alphabet: str, shift: int) -> List[List[str]]:
    """
    Create Auto-key table where each row uses Caesar cipher with different offsets.
    
    Args:
        alphabet: The alphabet to use for the table
        shift: Base shift for Caesar cipher
        
    Returns:
        A 2D list representing the Caesar-based Auto-key table
    """
    alphabet_len = len(alphabet)
    table = []
    
    for i in range(alphabet_len):
        row = []
        # Each row uses Caesar cipher with base_shift + row_index
        row_shift = shift + i
        for j in range(alphabet_len):
            row.append(alphabet[(j + row_shift) % alphabet_len])
        table.append(row)
    
    return table


def _create_affine_table(alphabet: str, a: int, b: int) -> List[List[str]]:
    """
    Create Auto-key table where each row uses Affine cipher with different offsets.
    
    Args:
        alphabet: The alphabet to use for the table
        a: Affine cipher parameter a
        b: Affine cipher parameter b
        
    Returns:
        A 2D list representing the Affine-based Auto-key table
    """
    alphabet_len = len(alphabet)
    table = []
    
    for i in range(alphabet_len):
        row = []
        # Each row uses Affine cipher with modified b
        row_b = b + i
        for j in range(alphabet_len):
            affine_result = (a * j + row_b) % alphabet_len
            row.append(alphabet[affine_result])
        table.append(row)
    
    return table


def _create_keyword_table(alphabet: str, keyword: str) -> List[List[str]]:
    """
    Create Auto-key table where each row uses Keyword cipher with different keywords.
    
    Args:
        alphabet: The alphabet to use for the table
        keyword: Base keyword for the cipher
        
    Returns:
        A 2D list representing the Keyword-based Auto-key table
    """
    alphabet_len = len(alphabet)
    table = []
    
    for i in range(alphabet_len):
        row = []
        # Each row uses keyword cipher with row character appended
        row_keyword = keyword + alphabet[i]  # Add row character to keyword
        transformed_alphabet = keyword_produce(row_keyword, alphabet)
        
        for j in range(alphabet_len):
            row.append(transformed_alphabet[j])
        table.append(row)
    
    return table


def _create_atbash_table(alphabet: str) -> List[List[str]]:
    """
    Create Auto-key table where each row uses Atbash cipher with different offsets.
    
    Args:
        alphabet: The alphabet to use for the table
        
    Returns:
        A 2D list representing the Atbash-based Auto-key table
    """
    alphabet_len = len(alphabet)
    table = []
    
    for i in range(alphabet_len):
        row = []
        # Each row uses Atbash cipher with rotation by row index
        for j in range(alphabet_len):
            atbash_index = (alphabet_len - 1 - j + i) % alphabet_len
            row.append(alphabet[atbash_index])
        table.append(row)
    
    return table


def produce_table(table_type: str, alphabet: str = DEFAULT_ALPHABET, **kwargs) -> List[List[str]]:
    """
    Produce an Auto-key table using different strategies.
    
    Args:
        table_type: Type of table ("classical", "caesar", "affine", "keyword", "atbash")
        alphabet: The alphabet to use for the table
        **kwargs: Additional parameters for specific table types
        
    Returns:
        A 2D list representing the Auto-key table
        
    Raises:
        ValueError: If table_type is not supported or parameters are missing
    """
    if not table_type:
        raise ValueError("Table type must be specified")
    
    if table_type == "classical":
        return _create_classical_table(alphabet)
    
    elif table_type == "caesar":
        if "shift" not in kwargs:
            raise ValueError("Caesar table requires 'shift' parameter")
        return _create_caesar_table(alphabet, kwargs["shift"])
    
    elif table_type == "affine":
        if "a" not in kwargs or "b" not in kwargs:
            raise ValueError("Affine table requires 'a' and 'b' parameters")
        return _create_affine_table(alphabet, kwargs["a"], kwargs["b"])
    
    elif table_type == "keyword":
        if "keyword" not in kwargs:
            raise ValueError("Keyword table requires 'keyword' parameter")
        return _create_keyword_table(alphabet, kwargs["keyword"])
    
    elif table_type == "atbash":
        return _create_atbash_table(alphabet)
    
    else:
        raise ValueError(f"Unsupported table type: {table_type}")


def _prepare_text(text: str, alphabet: str) -> str:
    """
    Prepare text for encryption by cleaning and handling special cases.
    
    Args:
        text: The input text
        alphabet: The alphabet being used
        
    Returns:
        Cleaned text ready for encryption
    """
    text_clean = ""
    for char in text.lower():
        if char.isalpha():
            # Handle custom alphabets
            if alphabet == DEFAULT_ALPHABET:
                # Apply language-specific replacements for English alphabet
                if 'ç' in alphabet.lower() or 'Ç' in alphabet:
                    # Turkish character replacements
                    if char == 'Ç':
                        char = 'C'
                    elif char == 'Ğ':
                        char = 'G'
                    elif char == 'I':
                        char = 'I'
                    elif char == 'Ö':
                        char = 'O'
                    elif char == 'Ş':
                        char = 'S'
                    elif char == 'Ü':
                        char = 'U'
            text_clean += char
        elif char == ' ':
            text_clean += ' '  # Preserve spaces
    return text_clean


def _prepare_ciphertext(ciphertext: str) -> str:
    """
    Prepare ciphertext for decryption by cleaning.
    
    Args:
        ciphertext: The input ciphertext
        
    Returns:
        Cleaned ciphertext ready for decryption
    """
    text_clean = ""
    for char in ciphertext.lower():
        if char.isalpha() or char == ' ':
            text_clean += char
    return text_clean


def _extend_key(key: str, plaintext: str, alphabet: str) -> str:
    """
    Extend the key using the plaintext (Auto-key mechanism).
    
    Args:
        key: The initial key
        plaintext: The plaintext to extend the key with
        alphabet: The alphabet being used
        
    Returns:
        Extended key combining initial key and plaintext
    """
    # Prepare plaintext (remove spaces and non-alphabetic characters)
    prepared_plaintext = ""
    for char in plaintext.lower():
        if char.isalpha() and char in alphabet:
            prepared_plaintext += char
    
    # Combine initial key with prepared plaintext
    extended_key = key + prepared_plaintext
    return extended_key


def _extend_key_for_decryption(key: str, decrypted_so_far: str, alphabet: str) -> str:
    """
    Extend the key for decryption using already decrypted text.
    
    Args:
        key: The initial key
        decrypted_so_far: The text decrypted so far
        alphabet: The alphabet being used
        
    Returns:
        Extended key for decryption
    """
    # Prepare decrypted text (remove spaces and non-alphabetic characters)
    prepared_decrypted = ""
    for char in decrypted_so_far.lower():
        if char.isalpha() and char in alphabet:
            prepared_decrypted += char
    
    # Combine initial key with prepared decrypted text
    extended_key = key + prepared_decrypted
    return extended_key


def encrypt(plaintext: str, key: str, alphabet: str = DEFAULT_ALPHABET, table: Optional[List[List[str]]] = None) -> str:
    """
    Encrypt plaintext using Auto-key cipher.
    
    Args:
        plaintext: The text to encrypt
        key: The Auto-key initial key
        table: Custom Auto-key table (uses classical if None)
        alphabet: The alphabet to use (defaults to English)
        
    Returns:
        Encrypted ciphertext
    """
    if not plaintext or not key:
        return ""
    
    # Use classical table if none provided
    if table is None:
        table = _create_classical_table(alphabet)
    
    # Prepare text
    prepared_text = _prepare_text(plaintext, alphabet)
    
    # Extend key using plaintext (Auto-key mechanism)
    extended_key = _extend_key(key, prepared_text, alphabet)
    
    result = ""
    key_index = 0
    
    for char in prepared_text:
        if char == ' ':
            result += ' '
            continue
        
        if char in alphabet:
            # Find character position in alphabet
            char_pos = alphabet.index(char)
            
            # Get key character from extended key
            key_char = extended_key[key_index % len(extended_key)]
            key_pos = alphabet.index(key_char)
            
            # Verify table structure
            if not isinstance(table[key_pos], list):
                table = _create_classical_table(alphabet)
            
            # Auto-key encryption: use table for encryption
            encrypted_char = table[key_pos][char_pos]
            result += encrypted_char
            
            key_index += 1
    
    return result


def decrypt(ciphertext: str, key: str, alphabet: str = DEFAULT_ALPHABET, table: Optional[List[List[str]]] = None) -> str:
    """
    Decrypt ciphertext using Auto-key cipher.
    
    Args:
        ciphertext: The text to decrypt
        key: The Auto-key initial key
        table: Custom Auto-key table (uses classical if None)
        alphabet: The alphabet to use (defaults to English)
        
    Returns:
        Decrypted plaintext
    """
    if not ciphertext or not key:
        return ""
    
    # Use classical table if none provided
    if table is None:
        table = _create_classical_table(alphabet)
    
    # Prepare ciphertext
    prepared_ciphertext = _prepare_ciphertext(ciphertext)
    
    result = ""
    key_index = 0
    decrypted_so_far = ""
    
    for char in prepared_ciphertext:
        if char == ' ':
            result += ' '
            continue
        
        if char in alphabet:
            # Extend key using already decrypted text
            extended_key = _extend_key_for_decryption(key, decrypted_so_far, alphabet)
            
            # Find character position in alphabet
            char_pos = alphabet.index(char)
            
            # Get key character from extended key
            key_char = extended_key[key_index % len(extended_key)]
            key_pos = alphabet.index(key_char)
            
            # Auto-key decryption: find plaintext character in table
            # Look for ciphertext character in the key row
            for col_idx, table_char in enumerate(table[key_pos]):
                if table_char == char:
                    decrypted_char = alphabet[col_idx]
                    result += decrypted_char
                    decrypted_so_far += decrypted_char
                    break
            else:
                # Fallback to modular arithmetic if character not found in table
                decrypted_pos = (char_pos - key_pos) % len(alphabet)
                decrypted_char = alphabet[decrypted_pos]
                result += decrypted_char
                decrypted_so_far += decrypted_char
            
            key_index += 1
    
    return result
